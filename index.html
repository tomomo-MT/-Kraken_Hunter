<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>射撃ゲーム・必殺技弾付き</title>
<style>
  body { margin: 0; overflow: hidden; background: skyblue; }
  canvas { display: block; margin: auto; background: #70c5ce; cursor: crosshair; }
</style>
</head>
<body>
<canvas id="game" width="1600" height="800"></canvas>

<!-- BGM -->
<audio id="bgm" src="boss.mp3" loop></audio>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// BGM
const bgm = document.getElementById("bgm");
bgm.volume = 0.01;
document.addEventListener("click", () => { bgm.play(); }, { once: true });

// ステージサイズ
const stageWidth = 1600;
const stageHeight = 800;

// プレイヤー
let player = { x: 200, y: 600, w: 64, h: 64, speed: 5, hp: 20 };
const playerImg = new Image();
playerImg.src = "player.png";

// 敵画像
const enemyImgs = { boss:new Image(), z1:new Image(), z2:new Image(), z3:new Image() };
enemyImgs.boss.src = "boss.png";
enemyImgs.z1.src = "enemy1.png";
enemyImgs.z2.src = "enemy2.png";
enemyImgs.z3.src = "enemy3.png";
// 弾
let bullets = [];
let enemyBullets = [];
let specialBullets = [];

// 敵
let enemies = [
  { type:"boss", x:1200, y:150, baseY:150, w:96, h:96, hp:100, attack:5, img:enemyImgs.boss },
  { type:"z1", x:1100, y:500, baseY:500, w:64, h:64, hp:30, attack:1, img:enemyImgs.z1 },
  { type:"z2", x:1350, y:550, baseY:550, w:64, h:64, hp:30, attack:2, img:enemyImgs.z2 },
  { type:"z3", x:800, y:550, baseY:550, w:64, h:64, hp:30, attack:2, img:enemyImgs.z3 }
];

// 障害物
let obstacles = [
  { x:600, y:300, w:100, h:50, vx:1.5, vy:0 },
  { x:900, y:200, w:50, h:200, vx:0, vy:1 },
  { x:1300, y:400, w:150, h:50, vx:-1, vy:0 },
  { x:500, y:500, w:80, h:80, vx:0, vy:-1.2 },
  { x:1400, y:300, w:60, h:60, vx:1, vy:1 }
];

// 毒
let poisonMargin = 0;
const poisonSpeed = 0.1; // 遅め

// 障害物更新
function updateObstacles(){
  obstacles.forEach(obs => {
    obs.x += obs.vx;
    obs.y += obs.vy;
    if(obs.x < 0 || obs.x + obs.w > stageWidth) obs.vx *= -1;
    if(obs.y < 0 || obs.y + obs.h > stageHeight) obs.vy *= -1;

    if(rectHit(player, obs)){
      if(player.x + player.w/2 < obs.x + obs.w/2) player.x = obs.x - player.w;
      else player.x = obs.x + obs.w;
      if(player.y + player.h/2 < obs.y + obs.h/2) player.y = obs.y - player.h;
      else player.y = obs.y + obs.h;
    }

    [bullets, enemyBullets, specialBullets].forEach(arr=>{
      arr.forEach(b=>{
        if(circleRectHit(b, obs)){
          if(b.x < obs.x || b.x > obs.x + obs.w) b.vx *= -1;
          if(b.y < obs.y || b.y > obs.y + obs.h) b.vy *= -1;
        }
      });
    });
  });
}

// 毒更新
function updatePoison(){
  poisonMargin += poisonSpeed;
  if(player.x < poisonMargin || player.x + player.w > stageWidth - poisonMargin ||
     player.y < poisonMargin || player.y + player.h > stageHeight - poisonMargin){
    player.hp -= 0.1;
    if(player.hp <= 0) gameOver();
  }
}

let score = 0;
let keys = {};
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

let isShooting = false;
let shootInterval = null;
let mouseX = 0, mouseY = 0;
canvas.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left + scrollX;
  mouseY = e.clientY - rect.top + scrollY;
});

function shootBullet(targetX, targetY){
  const dx = targetX - (player.x + player.w/2);
  const dy = targetY - (player.y + player.h/2);
  const len = Math.sqrt(dx*dx + dy*dy);
  const speed = 2; // 半分
  bullets.push({ x:player.x+player.w/2, y:player.y+player.h/2, vx:(dx/len)*speed, vy:(dy/len)*speed, r:5 });
}

canvas.addEventListener("mousedown", e => {
  isShooting = true;
  shootBullet(mouseX, mouseY);
  shootInterval = setInterval(() => { if(isShooting) shootBullet(mouseX, mouseY); }, 200);
});
canvas.addEventListener("mouseup", () => { isShooting = false; clearInterval(shootInterval); });

function rectHit(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
function circleRectHit(circle, rect){
  const cx = Math.max(rect.x, Math.min(circle.x, rect.x+rect.w));
  const cy = Math.max(rect.y, Math.min(circle.y, rect.y+rect.h));
  const dx = circle.x-cx; const dy = circle.y-cy;
  return (dx*dx + dy*dy) < (circle.r*circle.r);
}

function gameOver(){ alert("ゲームオーバー！\nスコア:"+score+"\nHPが0になりました"); document.location.reload(); }

let scrollX = 0, scrollY = 0;

function enemyShoot(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const len = Math.sqrt(dx*dx + dy*dy);
  const speed = 1.25; // 半分
  enemyBullets.push({ x:e.x+e.w/2, y:e.y+e.h/2, vx:dx/len*speed, vy:dy/len*speed, r:5, attack:e.attack, type:e.type });
}

let specialReady = true;
let specialCooldown = 0;

document.addEventListener("keydown", e => {
  if(e.key.toLowerCase() === "q" && specialReady){
    useSpecial(mouseX, mouseY);
    specialReady = false;
    specialCooldown = 300;
  }
});

function useSpecial(targetX, targetY){
  const dx = targetX - (player.x + player.w/2);
  const dy = targetY - (player.y + player.h/2);
  const len = Math.sqrt(dx*dx + dy*dy);
  const speed = 2.5; // 半分
  specialBullets.push({ x:player.x+player.w/2, y:player.y+player.h/2, vx:(dx/len)*speed, vy:(dy/len)*speed, r:15, range:100 });
}

let frame = 0;
function update(){
  frame++;
  updateObstacles();
  updatePoison();

  let newX=player.x, newY=player.y;
  if(keys["a"]) newX-=player.speed;
  if(keys["d"]) newX+=player.speed;
  if(keys["w"]) newY-=player.speed;
  if(keys["s"]) newY+=player.speed;
  newX=Math.max(0,Math.min(stageWidth-player.w,newX));
  newY=Math.max(0,Math.min(stageHeight-player.h,newY));
  if(!obstacles.some(obs=>rectHit({x:newX,y:newY,w:player.w,h:player.h},obs))){ player.x=newX; player.y=newY; }

  scrollX = Math.max(0, Math.min(stageWidth - canvas.width, player.x - canvas.width/2));
  scrollY = Math.max(0, Math.min(stageHeight - canvas.height, player.y - canvas.height/2));

  enemies.forEach(e=>{
    let freq = e.type==="boss"?0.03:0.05;
    let amp = e.type==="boss"?10:20;
    e.y = e.baseY + Math.sin(frame*freq + e.x)*amp;
  });

  bullets.forEach(b=>{ b.x+=b.vx; b.y+=b.vy; if(obstacles.some(obs=>circleRectHit(b,obs))) b.x=-100; });
  bullets = bullets.filter(b=>b.x>0 && b.x<stageWidth && b.y>0 && b.y<stageHeight);

  enemies.forEach(e=>{ bullets.forEach(b=>{ if(b.x>e.x && b.x<e.x+e.w && b.y>e.y && b.y<e.y+e.h && e.hp>0){ e.hp--; b.x=-100; if(e.hp<=0) score+= e.type==="boss"?1000:100; } }); });

  if(frame%120===0) enemies.forEach(e=>{ if(e.hp>0) enemyShoot(e); });

  enemyBullets.forEach(b=>{
    b.x+=b.vx; b.y+=b.vy;
    if(obstacles.some(obs=>circleRectHit(b,obs))) b.x=-100;
    if(circleRectHit(b,player)){ b.x=-100; player.hp-=b.attack; if(player.hp<=0) gameOver(); }
  });
  enemyBullets = enemyBullets.filter(b=>b.x>0 && b.x<stageWidth && b.y>0 && b.y<stageHeight);

  specialBullets.forEach(b=>{
    b.x+=b.vx; b.y+=b.vy;
    enemies.forEach(e=>{
      const dx = e.x+e.w/2 - b.x;
      const dy = e.y+e.h/2 - b.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist<=b.range && e.hp>0){ e.hp-=10; if(e.hp<=0) score+=e.type==="boss"?1000:100; }
    });
  });
  specialBullets = specialBullets.filter(b=>b.x>0 && b.x<stageWidth && b.y>0 && b.y<stageHeight);

  if(!specialReady){ specialCooldown--; if(specialCooldown<=0) specialReady=true; }

  // 敵全滅でステージクリア
  if(enemies.every(e=>e.hp <= 0)){
    alert("ステージクリア！\nスコア:"+score);
    document.location.reload();
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle = "rgba(128,0,0,0.3)";
  ctx.fillRect(0-scrollX,0-scrollY,stageWidth,poisonMargin);
  ctx.fillRect(0-scrollX,stageHeight-poisonMargin-scrollY,stageWidth,poisonMargin);
  ctx.fillRect(0-scrollX,0-scrollY,poisonMargin,stageHeight);
  ctx.fillRect(stageWidth-poisonMargin-scrollX,0-scrollY,poisonMargin,stageHeight);

  ctx.fillStyle="green";
  ctx.fillRect(0-scrollX, stageHeight-40-scrollY, stageWidth, 40);

  ctx.fillStyle="brown";
  obstacles.forEach(obs=>ctx.fillRect(obs.x-scrollX, obs.y-scrollY, obs.w, obs.h));

  enemies.forEach(e=>{
    if(e.hp>0){
      ctx.drawImage(e.img, e.x-scrollX, e.y-scrollY, e.w, e.h);
      ctx.fillStyle="red";
      ctx.fillRect(e.x-scrollX, e.y-10-scrollY, (e.hp/(e.type==="boss"?100:30))*60,5);
    }
  });

  ctx.fillStyle="yellow";
  bullets.forEach(b=>{ ctx.beginPath(); ctx.arc(b.x-scrollX,b.y-scrollY,b.r,0,Math.PI*2); ctx.fill(); });

  enemyBullets.forEach(b=>{
    ctx.beginPath();
    ctx.arc(b.x-scrollX,b.y-scrollY,b.r* (b.type==="boss"?2:1),0,Math.PI*2);
    ctx.fillStyle= b.type==="boss"? "yellow":"red";
    ctx.fill();
  });

  specialBullets.forEach(b=>{
    ctx.beginPath();
    ctx.arc(b.x-scrollX,b.y-scrollY,b.range,0,Math.PI*2);
    ctx.strokeStyle = "rgba(255,165,0,0.3)";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(b.x-scrollX,b.y-scrollY,b.r,0,Math.PI*2);
    ctx.fillStyle="orange";
    ctx.fill();
  });

  ctx.drawImage(playerImg, player.x-scrollX, player.y-scrollY, player.w, player.h);

  ctx.fillStyle="white";
  ctx.font="20px sans-serif";
  ctx.fillText("Score: "+score,20,30);
  ctx.fillText("HP: "+Math.floor(player.hp),20,60);
  ctx.fillText("Special: " + (specialReady ? "Ready" : Math.ceil(specialCooldown/60)+"s"), 20,90);

  drawMiniMap();
}

function drawMiniMap(){
  const scale = 0.1;
  const mapWidth = stageWidth*scale;
  const mapHeight = stageHeight*scale;
  const mapX = canvas.width-mapWidth-10;
  const mapY = 10;

  ctx.fillStyle="rgba(0,0,0,0.5)";
  ctx.fillRect(mapX,mapY,mapWidth,mapHeight);

  ctx.fillStyle="brown";
  obstacles.forEach(obs=>ctx.fillRect(mapX+obs.x*scale,mapY+obs.y*scale,obs.w*scale,obs.h*scale));

  ctx.fillStyle="blue";
  enemies.forEach(e=>{ if(e.hp>0) ctx.fillRect(mapX+e.x*scale,mapY+e.y*scale,e.w*scale,e.h*scale); });

  ctx.fillStyle="red";
  ctx.fillRect(mapX+player.x*scale,mapY+player.y*scale,player.w*scale,player.h*scale);

  ctx.fillStyle="orange";
  enemyBullets.forEach(b=>ctx.fillRect(mapX+b.x*scale,mapY+b.y*scale,b.r*2*scale,b.r*2*scale));
  specialBullets.forEach(b=>ctx.fillRect(mapX+b.x*scale,mapY+b.y*scale,b.r*2*scale,b.r*2*scale));
}

function loop(){ update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
