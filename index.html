<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>クラーケンハンター</title>
  <style>
  body { margin: 0; overflow: hidden; background: skyblue; }
      canvas { display: block; margin: auto; background: #70c5ce; cursor: crosshair; }
  </style>
</head>

<body>
  <canvas id="game" width="1600" height="800">
  </canvas>
  <audio id="bgm" src="boss.mp3" loop>
  </audio>
  <script>
  const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // BGM設定
    const bgm = document.getElementById("bgm");
    bgm.volume = 0.01;
    document.addEventListener("click", () => bgm.play(), { once: true });

    // ステージ設定
    const stageWidth = 1600, stageHeight = 800;

    // プレイヤー
    let player = { x:200, y:600, w:64, h:64, speed:5, hp:20 };
    const playerImg = new Image();
    playerImg.src = "player.png";
    let playerFlashTime = 0; // 被弾後のフラッシュ時間
    let playerInvincible = 0; // 無敵フレームカウント


    // 敵画像
    const enemyImgs = { boss:new Image(), z1:new Image(), z2:new Image(), z3:new Image() };
    enemyImgs.boss.src = "boss.png";
    enemyImgs.z1.src = "enemy1.png";
    enemyImgs.z2.src = "enemy2.png";
    enemyImgs.z3.src = "enemy3.png";

    // 敵
    let enemies = [
      { type:"boss", x:1200, y:150, w:96, h:96, hp:100, attack:5, img:enemyImgs.boss, vx:0.5, vy:0.5 },
      { type:"z1", x:1100, y:500, w:64, h:64, hp:30, attack:1, img:enemyImgs.z1, vx:0.8, vy:0.8 },
      { type:"z2", x:1350, y:550, w:64, h:64, hp:30, attack:2, img:enemyImgs.z2, vx:0.7, vy:0.7 },
      { type:"z3", x:800, y:550, w:64, h:64, hp:30, attack:2, img:enemyImgs.z3, vx:0.6, vy:0.6 }
    ];

    // 障害物
    let obstacles = [
      { x:600, y:300, w:100, h:50, vx:1.5, vy:0 },
      { x:900, y:200, w:50, h:200, vx:0, vy:1 },
      { x:1300, y:400, w:150, h:50, vx:-1, vy:0 },
      { x:500, y:500, w:80, h:80, vx:0, vy:-1.2 },
      { x:1400, y:300, w:60, h:60, vx:1, vy:1 }
    ];

    // 状態変数
    let poisonMargin = 0;
    const poisonSpeed = 0.05;
    let keys = {};
    let score = 0;
    let frame = 0;
    let scrollX = 0, scrollY = 0;

    // 斬撃データ
    let slashes = [];
    let slashCooldown = 0;
    // 敵の弾
    let enemyBullets = [];

    // 入力
    document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    // =============== 斬撃攻撃（クリックで発動） ===============
    canvas.addEventListener("mousedown", e => {
      if (slashCooldown > 0) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left + scrollX;
      const my = e.clientY - rect.top + scrollY;

      const dx = mx - (player.x + player.w / 2);
      const dy = my - (player.y + player.h / 2);
      const len = Math.sqrt(dx * dx + dy * dy);
      const dirX = dx / len;
      const dirY = dy / len;

      const range = 80;
      slashes.push({
        x: player.x + player.w / 2 + dirX * range,
        y: player.y + player.h / 2 + dirY * range,
        r: 60,
        life: 10,
        dirX, dirY,
        hitEnemies: [] // ← ここで当たった敵を記録
      });
      slashCooldown = 40;
    });

    // ===== 共通関数 =====
    function rectHit(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }

    // ===== 更新処理 =====
    function updateObstacles(){
      obstacles.forEach(obs => {
        obs.x += obs.vx;
        obs.y += obs.vy;
        if(obs.x < 0 || obs.x + obs.w > stageWidth) obs.vx *= -1;
        if(obs.y < 0 || obs.y + obs.h > stageHeight) obs.vy *= -1;

        if(rectHit(player, obs)){
          if(player.x + player.w/2 < obs.x + obs.w/2) player.x = obs.x - player.w;
          else player.x = obs.x + obs.w;
          if(player.y + player.h/2 < obs.y + obs.h/2) player.y = obs.y - player.h;
          else player.y = obs.y + obs.h;
        }
      });
    }

    function updatePoison(){
      poisonMargin += poisonSpeed;
      if(player.x < poisonMargin || player.x + player.w > stageWidth - poisonMargin ||
         player.y < poisonMargin || player.y + player.h > stageHeight - poisonMargin){
        player.hp -= 0.01;
        playerFlashTime = 3;
        if(player.hp <= 0) gameOver();
      }
    }

    function update(){
      frame++;
      updateObstacles();
      updatePoison();
      if (playerFlashTime > 0) playerFlashTime--;
      if (playerInvincible > 0) playerInvincible--;

      // プレイヤー移動
      let newX = player.x, newY = player.y;
      if(keys["a"]) newX -= player.speed;
      if(keys["d"]) newX += player.speed;
      if(keys["w"]) newY -= player.speed;
      if(keys["s"]) newY += player.speed;
      newX = Math.max(0, Math.min(stageWidth - player.w, newX));
      newY = Math.max(0, Math.min(stageHeight - player.h, newY));
      if(!obstacles.some(obs => rectHit({x:newX,y:newY,w:player.w,h:player.h}, obs))){
        player.x = newX; player.y = newY;
      }

      // スクロール更新
      scrollX = Math.max(0, Math.min(stageWidth - canvas.width, player.x - canvas.width / 2));
      scrollY = Math.max(0, Math.min(stageHeight - canvas.height, player.y - canvas.height / 2));

      // 斬撃更新
      if (slashCooldown > 0) slashCooldown--;
      slashes.forEach(s => {
        s.life--;
        enemies.forEach(e => {
          if (e.hp > 0 && !s.hitEnemies.includes(e)) { // ← 既に当たった敵を除外
            const dx = (e.x + e.w/2) - s.x;
            const dy = (e.y + e.h/2) - s.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < s.r) {
              e.hp -= 5; // プレイヤー攻撃力
              s.hitEnemies.push(e);
              if (e.hp <= 0) score += e.type === "boss" ? 1000 : 100;
            }
          }
        });
      });
      slashes = slashes.filter(s => s.life > 0);

      // 敵挙動・敵弾
      enemies.forEach(e => {
        if (e.hp <= 0) return;
          // shootCooldown が未定義なら初期化
        if (e.shootCooldown === undefined) {
          e.shootCooldown = Math.floor(Math.random() * 60) + 60; // 1〜2秒程度のランダム
        }
        // shootCooldownを1減らす
  if (e.shootCooldown > 0) e.shootCooldown--;

  // 弾を撃つ処理
  if (e.shootCooldown <= 0 && e.hp > 0) {
      const dx = player.x - e.x;
      const dy = player.y - e.y;
      const len = Math.sqrt(dx*dx + dy*dy);
      const speed = 3;
      let bulletDamage = e.type === "boss" ? 5 : 1;

      enemyBullets.push({
          x: e.x + e.w / 2,
          y: e.y + e.h / 2,
          vx: (dx / len) * speed,
          vy: (dy / len) * speed,
          r: 5,
          color: "orange",
          damage: bulletDamage
      });

      // 次に撃つまでの間隔をランダムで設定
      e.shootCooldown = Math.floor(Math.random() * 120) + 60;
  }

        if (e.type !== "boss") {
          if (!e.center) e.center = { x:e.x, y:e.y, w:150, h:100 };
          e.x += e.vx;
          e.y += e.vy;
          if (e.x < e.center.x - e.center.w/2 || e.x > e.center.x + e.center.w/2) e.vx *= -1;
          if (e.y < e.center.y - e.center.h/2 || e.y > e.center.y + e.center.h/2) e.vy *= -1;
        } else {
          const dx = player.x - e.x;
          const dy = player.y - e.y;
          const len = Math.sqrt(dx*dx + dy*dy);
          if(len > 0){
            const chaseSpeed = 0.4;
            e.x += (dx/len)*chaseSpeed;
            e.y += (dy/len)*chaseSpeed;
          }
        }

    if (e.shootCooldown <= 0 && e.hp > 0) {
      const dx = player.x - e.x;
      const dy = player.y - e.y;
      const len = Math.sqrt(dx * dx + dy * dy);
      const speed = 3; // 弾の速度

      // 敵の種類ごとに威力を設定
      let bulletDamage = 1; // デフォルト雑魚
      if(e.type === "boss") bulletDamage = 5; // ボスは強い

      enemyBullets.push({
        x: e.x + e.w / 2,
        y: e.y + e.h / 2,
        vx: (dx / len) * speed,
        vy: (dy / len) * speed,
        r: 5,
        color: "orange",
        damage: bulletDamage // ←ここで威力を保存
      });

      // 発射間隔を設定
      e.shootCooldown = Math.floor(Math.random() * 120) + 60; // 1〜2秒ごとに発射
    }
      });

      // 敵弾の移動
    enemyBullets.forEach(b => {
      b.x += b.vx;
      b.y += b.vy;

      const dx = (player.x + player.w / 2) - b.x;
    const dy = (player.y + player.h / 2) - b.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < b.r + player.w / 2 && playerInvincible === 0) {
      player.hp -= b.damage;      // 敵弾ごとの威力を適用
      playerFlashTime = 10;       // 赤フラッシュ
      playerInvincible = 30;      // 無敵時間（30フレーム）
      b.hit = true;

      if (player.hp <= 0) gameOver();
    }


      // 画面外に出た弾は削除
      if (b.x < 0 || b.x > stageWidth || b.y < 0 || b.y > stageHeight) b.hit = true;
    });

    enemyBullets = enemyBullets.filter(b => !b.hit);


      // 敵全滅チェック
      if (enemies.every(e => e.hp <= 0)) {
        alert("ステージクリア！\nスコア:" + score);
        document.location.reload();
      }
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // 毒
      ctx.fillStyle = "rgba(128,0,128,0.5)";
      ctx.fillRect(0-scrollX,0-scrollY,stageWidth,poisonMargin);
      ctx.fillRect(0-scrollX,stageHeight-poisonMargin-scrollY,stageWidth,poisonMargin);
      ctx.fillRect(0-scrollX,0-scrollY,poisonMargin,stageHeight);
      ctx.fillRect(stageWidth-poisonMargin-scrollX,0-scrollY,poisonMargin,stageHeight);

      // 地面
      ctx.fillStyle = "green";
      ctx.fillRect(0-scrollX, stageHeight-40-scrollY, stageWidth, 40);

      // 障害物
      ctx.fillStyle = "brown";
      obstacles.forEach(obs => ctx.fillRect(obs.x-scrollX, obs.y-scrollY, obs.w, obs.h));

      // 敵
      enemies.forEach(e => {
        if(e.hp > 0){
          ctx.drawImage(e.img, e.x-scrollX, e.y-scrollY, e.w, e.h);
          ctx.fillStyle = "red";
          ctx.fillRect(e.x-scrollX, e.y-10-scrollY, (e.hp/(e.type==="boss"?100:30))*60, 5);
        }
      });

      // 敵弾
      enemyBullets.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x - scrollX, b.y - scrollY, b.r, 0, Math.PI * 2);
        ctx.fillStyle = b.color;
        ctx.fill();
      });

      // 斬撃描画
      slashes.forEach(s => {
        ctx.beginPath();
        ctx.arc(s.x - scrollX, s.y - scrollY, s.r, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.6)";
        ctx.lineWidth = 3;
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(player.x + player.w/2 - scrollX, player.y + player.h/2 - scrollY);
        ctx.lineTo(s.x - scrollX, s.y - scrollY);
        ctx.strokeStyle = "rgba(255,255,255,0.4)";
        ctx.lineWidth = 5;
        ctx.stroke();
      });

      // プレイヤー
      if (playerFlashTime > 0) {
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.drawImage(playerImg, player.x - scrollX, player.y - scrollY, player.w, player.h);
        ctx.fillStyle = "rgba(255,0,0,0.5)";
        ctx.fillRect(player.x - scrollX, player.y - scrollY, player.w, player.h);
        ctx.restore();
      } else {
        ctx.drawImage(playerImg, player.x - scrollX, player.y - scrollY, player.w, player.h);
      }

      // UI
      ctx.fillStyle="white";
      ctx.font="20px sans-serif";
      ctx.fillText("HP: "+Math.floor(player.hp), 20, 30);
      ctx.fillText("Score: "+score, 20, 60);
    }

    // ===== ゲームオーバー =====
    function gameOver(){
      alert("ゲームオーバー！\nスコア:"+score);
      document.location.reload();
    }

    // ===== メインループ =====
    function loop(){ update(); draw(); requestAnimationFrame(loop); }
    loop();
  </script>
</body>

</html>